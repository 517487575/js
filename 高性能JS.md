# 如何使JS提高运行性能

## 数据的存取

Js中的存储方案

- 字面量：字符串、数字、布尔值、对象、数组、函数、正则表达式、null、undefined
- 本地变量：var定义的数据存储单元
- 数组元素：存储在js数组对象内部，以数字作为索引
- 对象成员：存储在js对象内部，以字符串作为索引

> 从字面量和局部变量中存取数据性能差异微不足道，访问数组和对象成员性能代价高一些。如果在乎运行速度，尽量使用字面量和局部变量，减少数组项和对象成员的使用。


### 作用域链

通过原型链知道函数都是Function对象的实例，Function对象和其他对象一样，拥有可以编程访问的属性，其中一个内部属性[[Scope]]包含了函数被创建的作用域中的对象的集合，这个集合被称为作用域链，作用域链决定了哪些数据可以被函数访问。作用域中的每个对象被称为可变对象，每个可变对象都以键值对的形式存在。

``` html
<script>
  function add(num1, num2) {
    var sum = num1 + num2
    return sum
  }
</script>
```

当add函数被初始化时（注意不是在add被执行的时候），在作用域链的顶部插入一个全局对象，代表着全局范围内定义的变量的集合，这些变量在add函数内可以被访问。

| add函数   |   作用域链   |   全局对象   |
| :-------- | :--------| :------ |
| [[Scope]]  |   0  |   this/window/document/add(注意此时add本身也是全局变量) |

> add函数的[[Scope]]属性指向了作用域链，作用域链中的首个对象指向全局对象（全局变量的集合）。

当add函数被执行时，会创建一个执行环境（执行上下文）的内部对象，一个执行环境定义了一个函数执行时的环境（函数每次的执行环境都是独一无二的），多次调用同一个函数会导致创建多个执行环境，函数执行完毕执行环境会被销毁。全局执行环境直到关闭网页或浏览器才会被销毁。



每个执行环境都有自己对应的作用域链，用于解析标识符。执行环境被创建的时候，作用域链初始化为当前运行函数的[[Scope]]属性中的对象。这些对象按照出现在函数中的顺序被复制到执行环境的作用域链中（前面说的全局对象，是在初始化的时候就在[[Scope]]中创建完成，而这里所说的是在执行函数中的除全局对象以外的和执行函数相关的局部变量、命名参数、参数集合以及this)，作用域链中复制的出现在函数中的对象(局部变量、命名参数、参数集合以及this)的新对象被称为活动对象。活动对象会被推入作用域链的最前端（后面是当前的执行环境的父执行环境的活动对象...一直到最后是全局对象）

| add函数   |   作用域链   |   活动对象和全部对象   |
| :-------- | :--------| :------ |
| [[Scope]]  |   0  |  this/arguments/num1/num2/sum  |
| [[Scope]]  |   1  |   this/window/document/add(注意此时add本身也是全局变量) |

函数在执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取或存储数据。该过程主要是依靠作用域链进行解析，首先搜索当前执行环境的活动对象，如果找到标识符对应的变量则终止搜索，否则继续搜索作用域链的下一个对象，搜索的过程会持续进行，直到全局对象，如果在全局对象中都没有匹配标识符的变量，那么该变量是未定义的（undefined）。

> 搜索是会消耗性能的，可以清楚的知道当前执行环境的活动对象的搜索是最快的，而全局对象的搜索则是最耗性能的。并且可以发现如果存在相同的变量，根据作用域链的搜索顺序决定先搜索到的变量被执行。如果某个跨作用域链的值在当前执行环境中被引用不止一次时，可以存储到局部变量中从而提升搜索性能。


需要注意作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。


### 改变作用域链

#### with

尽量不要使用with，可能会使局部变量的访问代价更大，因为with会创建新的作用域。


#### catch


try代码如果发生错误，执行过程会自动跳转到catch子句，然后把异常对象推入一个变量对象并置于作用域的首位，在catch代码块内部，函数所有的局部变量将会放在第二个作用域链对象中。

为了尽量简化代码使得catch子句对性能的影响最小化，推荐的做法是将错误委托给一个函数来处理

``` html
<script>
  try {
    // ...
  } catch(err) {
    fn2(err)
  }
</script>
```

> 函数fn2是catch子句中唯一执行的代码，该函数接受错误产生的异常对象为参数，由于只执行一条语句，且没有局部变量的访问，作用域的临时改变不会影响代码性能。需要注意with或catch或eval子句被称为动态作用域，动态作用域只存在代码执行过程，无法通过静态分析，因此只有确实必要时才推荐使用动态作用域。

### 闭包、作用域和内存

闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式就是在一个函数内部创建另一个函数。

闭包可以访问局部作用域之外的数据，可能会导致性能问题。通常函数在执行完毕后会销毁执行环境，内存中仅保存全局作用域Global variable object，但是闭包的情况不同

``` html
<script>
  function fn() {
    var id = "ziyi2"
    //一个匿名的内部函数
    return function(obj1,obj2) {
      var value1 = obj1[id];
      var value2 = obj2[id];
      return value1 - value2
    }
  }
</script>
```

| fn执行环境  |   作用域链   |   活动对象和全部对象   |
| :-------- | :--------| :------ |
| [[Scope]]  |   0  |  this/arguments/id  |
| [[Scope]]  |   1  |  this/window/fn |



| 匿名函数（闭包）  |   作用域链   |   活动对象和全部对象   |
| :-------- | :--------| :------ |
| [[Scope]]  |   0  |  this/arguments/id  |
| [[Scope]]  |   1  |  this/window/fn |

当fn被执行的时候，fn执行环境对应的活动对象被创建（包含id变量），成为作用域链中的第一个对象，需要注意此时匿名函数被创建（fn执行的过程中创建了匿名函数），因此匿名函数的[[Scope]]属性被初始化为fn执行环境对应的作用域链。如果此时匿名函数被其他变量进行引用，那么尽管fn执行完毕，但是fn执行环境对应的活动对象并不会被销毁，因为很简单啊，匿名函数还需要访问fn执行环境的活动对象啊

